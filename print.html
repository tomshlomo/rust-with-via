<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust with Via</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Welcome to Rust with Via</a></li><li class="chapter-item expanded affix "><a href="schedule.html">Schedule</a></li><li class="chapter-item expanded affix "><li class="part-title">Exercises</li><li class="chapter-item expanded "><a href="stdlib-traits/index.html"><strong aria-hidden="true">1.</strong> Standard Library Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stdlib-traits/solution.html"><strong aria-hidden="true">1.1.</strong> Solution</a></li><li class="chapter-item expanded "><a href="stdlib-traits/instructor.html"><strong aria-hidden="true">1.2.</strong> Instructor Notes</a></li></ol></li><li class="chapter-item expanded "><a href="borrowing/index.html"><strong aria-hidden="true">2.</strong> Borrowing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="borrowing/solution.html"><strong aria-hidden="true">2.1.</strong> Solution</a></li><li class="chapter-item expanded "><a href="borrowing/instructor.html"><strong aria-hidden="true">2.2.</strong> Instructor Notes</a></li></ol></li><li class="chapter-item expanded "><a href="lifetimes/index.html"><strong aria-hidden="true">3.</strong> Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes/solution.html"><strong aria-hidden="true">3.1.</strong> Solution</a></li><li class="chapter-item expanded "><a href="lifetimes/instructor.html"><strong aria-hidden="true">3.2.</strong> Instructor Notes</a></li></ol></li><li class="chapter-item expanded "><a href="pyo3/index.html"><strong aria-hidden="true">4.</strong> Python Extension Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pyo3/solution.html"><strong aria-hidden="true">4.1.</strong> Solution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pyo3/simple_solution.html"><strong aria-hidden="true">4.1.1.</strong> Simple Solution</a></li><li class="chapter-item expanded "><a href="pyo3/faster_solution.html"><strong aria-hidden="true">4.1.2.</strong> Faster Solution</a></li></ol></li><li class="chapter-item expanded "><a href="pyo3/instructor.html"><strong aria-hidden="true">4.2.</strong> Instructor Notes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust with Via</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-rust-with-via"><a class="header" href="#welcome-to-rust-with-via">Welcome to Rust with Via</a></h1>
<p>This website contains complementary material for
<a href="https://google.github.io/comprehensive-rust/">Comprehensive Rust</a>,
an amazing Rust course developed by the Android team at Google.
It is based on the changes we made to the course while running it at
<a href="https://ridewithvia.com/">Via</a>
to make it more suitable for our Python-centric team.</p>
<p>Our primary motivation for offering this course was to promote the adoption of Rust within Via.
We believe that Rust's combination of performance, safety, and focus on resilient software aligns well with our organization's goals.
By introducing our colleagues to Rust, we hoped to inspire them to explore its potential benefits and consider incorporating it into their projects.</p>
<p>The course's objectives were to:</p>
<ul>
<li><strong>Convince students of Rust's value:</strong> Highlight Rust's rich type system, strong performance, and modern tooling.
Demonstrate how Rust's focus on safety can help identify and prevent bugs earlier in the development process, reducing the need for extensive QA and mitigating production issues.</li>
<li><strong>Introduce Rust's fundamentals:</strong> Show students that even though Rust definitely has it's complexities, using it to build reliable, performant and useful software is not that hard.</li>
<li><strong>Build confidence and motivation:</strong> Equip students with the knowledge and skills necessary to feel comfortable and excited about using Rust in their work.</li>
</ul>
<p>The course was attended by approximately 15 developers from our algorithms group. Given their extensive experience with Python, and the fact the the original course seem more oriented towards C++ developers, we made several adjustments to the original curriculum.
Most notably, we added a dedicated section and an exercise on using pyo3 to create native Python extensions. Additionally, we replaced some of the exercises with problems that were more relevant to our team's work.</p>
<p>To enhance the learning experience, we encouraged students to use VSCode as their development environment. We spent time setting up VSCode with essential tools like rust analyzer, clippy, and rustfmt to streamline their workflow.</p>
<p>At the conclusion of the workshop, we conducted a survey to gather feedback from the participants. The results were very positive, with 90% of respondents expressing a desire to use Rust in their projects and 80% feeling confident in their ability to do so with appropriate guidance.
You can find the full results <a href="url">here</a>.</p>
<p>We hope that you will find the materials on this site useful and that they will inspire you to explore Rust further. Happy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schedule"><a class="header" href="#schedule">Schedule</a></h1>
<p>The course was divided into 4 days and 2 weeks, with each week consisting of 2 consecutive days.
Each day was about 5 hours long, with a 1-hour break for lunch.</p>
<p>We mostly followed the schedule suggested in the original course, but we made some adjustments to better suit our team's needs, detailed below.</p>
<h2 id="day-1"><a class="header" href="#day-1">Day 1</a></h2>
<p>We covered the first day of the original course, and the first part of the second day (<a href="https://google.github.io/comprehensive-rust/pattern-matching.html">Pattern Matching</a>).
We skipped the <a href="https://google.github.io/comprehensive-rust/tuples-and-arrays/exercise.html">Nested Arrays</a> and <a href="https://google.github.io/comprehensive-rust/user-defined-types/exercise.html">Elevator Events</a> exercises, and concluded the day with the <a href="https://google.github.io/comprehensive-rust/pattern-matching/exercise.html">Expression Evaluation</a> exercise.</p>
<h2 id="day-2"><a class="header" href="#day-2">Day 2</a></h2>
<p>We used the time saved from the first day to open the day with a 45-minutes "why Rust" discussion.
This session provided an opportunity to delve into Rust's unique features and explain how they can benefit our work.
While it might seem unconventional to have this discussion later in the course, we found that it allowed for a more technical and concrete conversation.</p>
<p>Some of the topics we covered included:</p>
<ul>
<li>Rust unique memory model that eliminates memory management bugs without a garbage collector or any runtime.</li>
<li>Rust's rich type system that allows for expressive and safe code. Specifically we mentioned:
<ul>
<li>Unique and shared references types.</li>
<li>Mutability of a variable in the function signature/declaration.</li>
<li>Rust's enums that can have data attached to them.</li>
<li>Functions that can consume variables.</li>
<li>Rust unique error handling mechanism.</li>
<li>No object-oriented programming, but focus on composition through traits.
We focused on how these features can help us write more reliable and maintainable code.</li>
</ul>
</li>
<li>Rust's "Fearless Concurrency" model that allows for safe and efficient parallelism.</li>
<li>Zero-cost abstractions that allow for high-level programming without sacrificing performance.
<ul>
<li>Monomorphization.</li>
<li>The newtype pattern.</li>
</ul>
</li>
<li>Modern tooling that makes Rust development a breeze.
<ul>
<li>Cargo.</li>
<li>rustfmt.</li>
<li>clippy.</li>
<li>rust-analyzer.</li>
<li>Documentation generation.</li>
</ul>
</li>
<li>Easy to write Python extensions. Several known Python projects are using Rust, including
<a href="https://docs.pydantic.dev/latest/">Pydantic</a>,
<a href="https://pola.rs/">Polars</a>,
<a href="https://docs.astral.sh/ruff/">Ruff</a>,
<a href="https://github.com/huggingface/tokenizers">tokenizers</a>,
<a href="https://github.com/ijl/orjson">orjson</a>
and <a href="https://cryptography.io/en/latest/">cryptography</a>.</li>
<li>Rust is gaining popularity in the industry. It is used by major companies, and currently in the top 20 most popular languages according to the <a href="https://www.tiobe.com/tiobe-index/">TIOBE index</a>.</li>
<li>Programming in Rust is fun! It is the most admired language for the 8'th year in a row according to the <a href="https://survey.stackoverflow.co/2023/#section-admired-and-desired-programming-scripting-and-markup-languages">Stack Overflow Developer Survey</a>.</li>
<li>We also discussed some of Rust's drawbacks, including:
<ul>
<li>Steeper learning curve.</li>
<li>Slower compilation times.</li>
<li>Lack of mature libraries in some domains.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>In this exercise, we implement standard traits on <code>Inventory</code>, a type that represents an inventory list for a store.</p>
<p>You will need to implement two traits:</p>
<ol>
<li><code>From&lt;Vec&lt;(String, i32)&gt;&gt;</code> to construct an <code>Inventory</code> from a vector of item name-quantity pairs.</li>
<li><code>Add&lt;Inventory&gt;</code> to merge two inventories.</li>
</ol>
<p>You can test your implementation by running <code>cargo test</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

pub struct Inventory {
    items: HashMap&lt;String, u32&gt;,
}

// todo: implement the `From&lt;Vec&lt;(String, u32)&gt;&gt;` trait for `Inventory`.

// todo: implement the `Add&lt;Inventory&gt;` trait for `Inventory`.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_vec() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory: Inventory = items.into();
        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(inventory.items, expected);
    }

    #[test]
    fn test_from_empty_vec() {
        let items: Vec&lt;(String, u32)&gt; = Vec::new();
        let inventory: Inventory = items.into();
        let expected: HashMap&lt;String, u32&gt; = HashMap::new();
        assert_eq!(inventory.items, expected);
    }

    #[test]
    fn test_add() {
        let items1 = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let items2 = vec![("banana".to_string(), 5), ("orange".to_string(), 15)];
        let inventory1: Inventory = items1.into();
        let inventory2: Inventory = items2.into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; = [
            ("apple".to_string(), 10),
            ("banana".to_string(), 25),
            ("orange".to_string(), 15),
        ]
        .iter()
        .cloned()
        .collect();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_empty_inventories() {
        let inventory1: Inventory = Vec::new().into();
        let inventory2: Inventory = Vec::new().into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; = HashMap::new();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_non_empty_with_empty_inventory() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory1: Inventory = items.into();
        let inventory2: Inventory = Vec::new().into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_empty_with_non_empty_inventory() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory1: Inventory = Vec::new().into();
        let inventory2: Inventory = items.into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(combined_inventory.items, expected);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::convert::From;
use std::ops::Add;

pub struct Inventory {
    items: HashMap&lt;String, u32&gt;,
}

impl From&lt;Vec&lt;(String, u32)&gt;&gt; for Inventory {
    fn from(items: Vec&lt;(String, u32)&gt;) -&gt; Self {
        let mut inventory = HashMap::new();
        for (name, qty) in items {
            inventory.insert(name, qty);
        }
        Self { items: inventory }
        // We will learn more about iterators in day 4, but here is a more idiomatic way to do the above:
        // Self {
        //     items: items.into_iter().collect(),
        // }
    }
}

impl Add for Inventory {
    type Output = Inventory;

    fn add(self, other: Inventory) -&gt; Inventory {
        let mut combined = self.items;
        for (name, qty) in other.items {
            // This is a more idiomatic way to do the following:
            // match combined.get(&amp;name) {
            //     Some(existing_qty) =&gt; {
            //         combined.insert(name, existing_qty + qty);
            //     }
            //     None =&gt; {
            //         combined.insert(name, qty);
            //     }
            // }
            *combined.entry(name).or_insert(0) += qty;
        }
        Self { items: combined }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_vec() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory: Inventory = items.into();
        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(inventory.items, expected);
    }

    #[test]
    fn test_from_empty_vec() {
        let items: Vec&lt;(String, u32)&gt; = Vec::new();
        let inventory: Inventory = items.into();
        let expected: HashMap&lt;String, u32&gt; = HashMap::new();
        assert_eq!(inventory.items, expected);
    }

    #[test]
    fn test_add() {
        let items1 = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let items2 = vec![("banana".to_string(), 5), ("orange".to_string(), 15)];
        let inventory1: Inventory = items1.into();
        let inventory2: Inventory = items2.into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; = [
            ("apple".to_string(), 10),
            ("banana".to_string(), 25),
            ("orange".to_string(), 15),
        ]
        .iter()
        .cloned()
        .collect();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_empty_inventories() {
        let inventory1: Inventory = Vec::new().into();
        let inventory2: Inventory = Vec::new().into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; = HashMap::new();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_non_empty_with_empty_inventory() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory1: Inventory = items.into();
        let inventory2: Inventory = Vec::new().into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(combined_inventory.items, expected);
    }

    #[test]
    fn test_add_empty_with_non_empty_inventory() {
        let items = vec![("apple".to_string(), 10), ("banana".to_string(), 20)];
        let inventory1: Inventory = Vec::new().into();
        let inventory2: Inventory = items.into();

        let combined_inventory = inventory1 + inventory2;

        let expected: HashMap&lt;String, u32&gt; =
            [("apple".to_string(), 10), ("banana".to_string(), 20)]
                .iter()
                .cloned()
                .collect();
        assert_eq!(combined_inventory.items, expected);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructor-notes"><a class="header" href="#instructor-notes">Instructor Notes</a></h1>
<ul>
<li>
<p>This exercise is intended to replace the <a href="https://google.github.io/comprehensive-rust/std-traits/exercise.html#exercise-rot13">ROT13</a> exercise from the original version.</p>
</li>
<li>
<p>Students can choose whether the implementation of <code>From&lt;Vec&lt;(String, i32)&gt;&gt;</code> adds the quantities of duplicate names or keeps the last one.</p>
</li>
<li>
<p>Ensure that students who finish early use the <code>entry</code> API to implement <code>Add</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>In this exercise, you will implement a non-empty vector type. This type is a vector that is compile-time guaranteed to have at least one element. It can be useful when you want to ensure that a vector is never empty and avoid the overhead of checking for emptiness.</p>
<p>For example, a function can return a <code>NonEmptyVec&lt;T&gt;</code> instead of a <code>Vec&lt;T&gt;</code> to guarantee to its caller that the vector has at least one element. Or, a function can receive a <code>NonEmptyVec&lt;T&gt;</code> as an argument to force the caller to guarantee that the vector has at least one element.</p>
<h2 id="to-do"><a class="header" href="#to-do">To do</a></h2>
<ol>
<li>
<p>Implement the following methods for <code>NonEmptyVec</code>:</p>
<ul>
<li><code>new</code>: creates a new <code>NonEmptyVec</code> with a single element.</li>
<li><code>push</code>: pushes an element to the end of the <code>NonEmptyVec</code>.</li>
<li><code>get</code>: returns the element at the given index, if it exists.</li>
<li><code>first</code> (<code>last</code>): returns the first (last) element of the <code>NonEmptyVec</code>. Unlike <code>Vec::first</code>, this method should not return an Option!</li>
<li><code>first_mut</code> (<code>last_mut</code>): returns a mutable reference to the first (last) element of the <code>NonEmptyVec</code>.</li>
<li><code>pop</code>: removes the last element from the <code>NonEmptyVec</code> and returns it, along with the remaining elements. Unlike <code>Vec::pop</code>, this method should not return an Option (pop should succeed even if there is a single element).</li>
</ul>
<p>Think carefully about the signature of these methods. For each input and output argument, consider whether it should be owned, borrowed, or mutably borrowed.</p>
</li>
<li>
<p>Fill in the missing parts in the unit tests below (We didn't write the full tests for you to avoid spoiling the signatures).</p>
<p>You can test your implementation by running <code>cargo test</code>.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NonEmptyVec&lt;T&gt; {
    head: T,
    tail: Vec&lt;T&gt;,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new() {
        let x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        todo!("assert that x.first() returns 5, and that x.last() also returns 5.");
    }

    #[test]
    fn test_push() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        todo!("assert that x.first() returns 5, and that x.last() returns 10.");
    }

    #[test]
    fn test_get() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        x.push(15);
        todo!("check the result of `x.get` for indices 0, 1, 2 and 3");
    }

    #[test]
    fn test_first_mut() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        todo!("use `x.first_mut()` to modify the first item, and then assert that `x.first()` returns the modified value.");
    }

    #[test]
    fn test_last_mut() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        todo!("use `x.last_mut()` to modify the last item, and then assert that `x.last()` returns the modified value.");
    }

    #[test]
    fn test_pop() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        x.push(15);
        todo!("call `x.pop()`, and verify that the popped item is 15, and the remaining values are 5 and 10.");
    }

    #[test]
    fn test_pop_single_item() {
        let x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        todo!("call `x.pop()`, and verify that the popped item is 5, and that there are no remaining values.");
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-1"><a class="header" href="#solution-1">Solution</a></h1>
<p><a href="https://docs.rs/nonempty/latest/nonempty/">nonempty</a>,
<a href="https://docs.rs/non-empty-vec/latest/non_empty_vec/">non_empty_vec</a>,
and
<a href="https://docs.rs/vec1/latest/vec1/">vec1</a>
are crates that implement a non-empty vector type.
Out implementation is similar to the one in <code>nonempty</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NonEmptyVec&lt;T&gt; {
    head: T,
    tail: Vec&lt;T&gt;,
}

impl&lt;T&gt; NonEmptyVec&lt;T&gt; {
    pub fn new(item: T) -&gt; Self {
        NonEmptyVec {
            head: item,
            tail: Vec::new(),
        }
    }
    pub fn push(&amp;mut self, item: T) {
        self.tail.push(item);
    }
    pub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        if index == 0 {
            Some(&amp;self.head)
        } else {
            self.tail.get(index - 1)
        }
    }
    pub fn first(&amp;self) -&gt; &amp;T {
        &amp;self.head
    }
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut self.head
    }
    pub fn last(&amp;self) -&gt; &amp;T {
        self.tail.last().unwrap_or(&amp;self.head)
    }
    pub fn last_mut(&amp;mut self) -&gt; &amp;mut T {
        self.tail.last_mut().unwrap_or(&amp;mut self.head)
    }
    pub fn pop(mut self) -&gt; (T, Vec&lt;T&gt;) {
        match self.tail.pop() {
            Some(item) =&gt; (item, self.into()),
            None =&gt; (self.head, Vec::new()),
        }
    }
}

impl&lt;T&gt; From&lt;NonEmptyVec&lt;T&gt;&gt; for Vec&lt;T&gt; {
    fn from(x: NonEmptyVec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
        let mut vec = vec![x.head];
        vec.extend(x.tail);
        vec
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new() {
        let x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        assert_eq!(x.first(), &amp;5);
        assert_eq!(x.last(), &amp;5);
    }

    #[test]
    fn test_push() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        assert_eq!(x.first(), &amp;5);
        assert_eq!(x.last(), &amp;10);
    }

    #[test]
    fn test_get() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        x.push(15);
        assert_eq!(x.get(0), Some(&amp;5));
        assert_eq!(x.get(1), Some(&amp;10));
        assert_eq!(x.get(2), Some(&amp;15));
        assert_eq!(x.get(3), None);
    }

    #[test]
    fn test_first_mut() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        *x.first_mut() = 10;
        assert_eq!(x.first(), &amp;10);
    }

    #[test]
    fn test_last_mut() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        *x.last_mut() = 15;
        assert_eq!(x.last(), &amp;15);
    }

    #[test]
    fn test_pop() {
        let mut x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        x.push(10);
        x.push(15);
        let (item, y) = x.pop();
        assert_eq!(item, 15);
        assert_eq!(y, vec![5, 10]);
    }

    #[test]
    fn test_pop_single_item() {
        let x: NonEmptyVec&lt;i32&gt; = NonEmptyVec::new(5);
        let (item, y) = x.pop();
        assert_eq!(item, 5);
        assert!(y.is_empty());
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructor-notes-1"><a class="header" href="#instructor-notes-1">Instructor Notes</a></h1>
<ul>
<li>
<p>This exercise is intended to replace the <a href="https://google.github.io/comprehensive-rust/borrowing/exercise.html">Health Statistics Exercise</a> exercise from the original version.</p>
</li>
<li>
<p>The solution includes links to several existing crates.
If you have time, it can be beneficial to review their source code.
In particular, <code>non_empty_vec</code> and <code>vec1</code> take different approaches of wrapping a regular <code>Vec</code>.</p>
</li>
<li>
<p>You can ask students who finish early to replace</p>
</li>
</ul>
<pre><code class="language-rust ignore">pub struct NonEmptyVec&lt;T&gt; {
    head: T,
    tail: Vec&lt;T&gt;,
}</code></pre>
<p>with</p>
<pre><code class="language-rust ignore">pub struct NonEmptyVec&lt;T&gt;(Vec&lt;T&gt;)</code></pre>
<p>and fix the body of all the methods accordingly.</p>
<ul>
<li>Our requirements that <code>pop</code> should succeed even when there is a single item is different from what these crates implement.
We required it since it forces <code>pop</code> to take ownership of <code>self</code>.
Consuming methods are quite unique to Rust so this can lead to an interesting discussion on how to (safely) implement <code>pop</code> in another language.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-1"><a class="header" href="#lifetimes-1">Lifetimes</a></h1>
<blockquote>
<p>This exercise is mostly taken from
<a href="https://github.com/tfpk/lifetimekata/blob/main/exercises/05_lifetimes_on_types/exercise/src/lib.rs">exercise 5</a>
of <a href="https://tfpk.github.io/lifetimekata/">LifetimeKata</a>.</p>
</blockquote>
<p>In this exercise, we implement a function that, given two sentences, returns the words that are present in the first sentence but not in the second, and vice versa.
The resulting struct <code>Difference</code> holds references to the words in the original sentences (rather copies of the words), so we need to ensure that the lifetimes are correct.</p>
<p>You need to implement the missing parts of the function <code>find_difference</code> and make the tests pass.
Note that this includes adding lifetime specifiers to both <code>find_difference</code> and <code>Difference</code>.</p>
<p>You can test your implementation by running <code>cargo test</code>.</p>
<blockquote>
<details>
  <summary>Read more</summary>
<p>Having <code>Difference</code> hold references to the original sentences is a design choice.
It could also hold the words themselves like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Difference {
    first_only: Vec&lt;String&gt;,
    second_only: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This would simplify the implementation (no lifetime specifiers needed) but would be less efficient (as we would be copying the words).
In real life, we often accept this trade-off and prefer the simpler solution, as it would be efficient enough.</p>
</details>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

#[derive(Debug, Default)]
pub struct Difference {
    first_only: Vec&lt;&amp;str&gt;,
    second_only: Vec&lt;&amp;str&gt;,
}

fn words(sentence: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    sentence
        .split(' ')
        .filter(|word| !word.is_empty()) // this makes sure we don't have empty words
        .collect()
}

pub fn find_difference(sentence1: &amp;str, sentence2: &amp;str) -&gt; Difference {
    let sentence_1_words = words(sentence1);
    let sentence_2_words = words(sentence2);

    let diff = Difference::default();

    todo!("implement the rest!");
    // hint: iterate on the words of each sentence and use the `contains` method of `HashSet`

    // sorting simplifies the equality assertions below
    diff.first_only.sort();
    diff.second_only.sort();

    diff
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_completely_disjoint_sentences() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "dog elephant fox";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple", "banana", "cherry"]);
        assert_eq!(result.second_only, vec!["dog", "elephant", "fox"]);
    }

    #[test]
    fn test_identical_sentences() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "apple banana cherry";
        let result = find_difference(sentence1, sentence2);

        assert!(result.first_only.is_empty());
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_some_common_words() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "banana cherry dog";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple"]);
        assert_eq!(result.second_only, vec!["dog"]);
    }

    #[test]
    fn test_empty_sentences() {
        let sentence1 = "";
        let sentence2 = "";
        let result = find_difference(sentence1, sentence2);

        assert!(result.first_only.is_empty());
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_one_empty_sentence() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple", "banana", "cherry"]);
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_drop_first_sentence_before_second() {
        todo!("Uncomment the code bellow once the rest of tests pass");
        // let sentence1 = String::from("A long sentence that takes up a lot of memory. We want to drop it as soon as possible.");
        // let sentence2 =
        //     String::from("A short sentence, we are ok with keeping around for a while.");
        // let Difference {
        //     first_only,
        //     second_only,
        // } = find_difference(&amp;sentence1, &amp;sentence2);

        // #[rustfmt::skip]
        // assert_eq!(
        //     first_only,
        //     vec! ["We", "as", "drop", "it", "long", "lot", "memory.", "of", "possible.", "sentence", "soon", "takes", "that", "to", "up", "want"],
        // );
        // drop(sentence1);

        // #[rustfmt::skip]
        // assert_eq!(
        //     second_only,
        //     vec! ["are", "around", "for", "keeping", "ok", "sentence,", "short", "we", "while.", "with"],
        // );
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-2"><a class="header" href="#solution-2">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

#[derive(Debug, Default)]
pub struct Difference&lt;'a, 'b&gt; {
    first_only: Vec&lt;&amp;'a str&gt;,
    second_only: Vec&lt;&amp;'b str&gt;,
}

pub fn words(sentence: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    sentence
        .split(' ')
        .filter(|word| !word.is_empty()) // this makes sure we don't have empty words
        .collect()
}

pub fn find_difference&lt;'a, 'b&gt;(sentence1: &amp;'a str, sentence2: &amp;'b str) -&gt; Difference&lt;'a, 'b&gt; {
    // lifetime annotations here are not required, added for clarity
    let sentence_1_words: HashSet&lt;&amp;'a str&gt; = words(sentence1);
    let sentence_2_words: HashSet&lt;&amp;'b str&gt; = words(sentence2);

    let mut diff = Difference::default();

    for word in &amp;sentence_1_words {
        if !sentence_2_words.contains(word) {
            diff.first_only.push(word)
        }
    }

    for word in &amp;sentence_2_words {
        if !sentence_1_words.contains(word) {
            diff.second_only.push(word)
        }
    }

    // sorting simplifies the equality assertions below
    diff.first_only.sort();
    diff.second_only.sort();

    diff
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_completely_disjoint_sentences() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "dog elephant fox";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple", "banana", "cherry"]);
        assert_eq!(result.second_only, vec!["dog", "elephant", "fox"]);
    }

    #[test]
    fn test_identical_sentences() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "apple banana cherry";
        let result = find_difference(sentence1, sentence2);

        assert!(result.first_only.is_empty());
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_some_common_words() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "banana cherry dog";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple"]);
        assert_eq!(result.second_only, vec!["dog"]);
    }

    #[test]
    fn test_empty_sentences() {
        let sentence1 = "";
        let sentence2 = "";
        let result = find_difference(sentence1, sentence2);

        assert!(result.first_only.is_empty());
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_one_empty_sentence() {
        let sentence1 = "apple banana cherry";
        let sentence2 = "";
        let result = find_difference(sentence1, sentence2);

        assert_eq!(result.first_only, vec!["apple", "banana", "cherry"]);
        assert!(result.second_only.is_empty());
    }

    #[test]
    fn test_drop_first_sentence_before_second() {
        let sentence1 = String::from("A long sentence that takes up a lot of memory. We want to drop it as soon as possible.");
        let sentence2 =
            String::from("A short sentence, we are ok with keeping around for a while.");
        let Difference {
            first_only,
            second_only,
        } = find_difference(&amp;sentence1, &amp;sentence2);

        #[rustfmt::skip]
        assert_eq!(
            first_only,
            vec! ["We", "as", "drop", "it", "long", "lot", "memory.", "of", "possible.", "sentence", "soon", "takes", "that", "to", "up", "want"],
        );
        drop(sentence1);

        #[rustfmt::skip]
        assert_eq!(
            second_only,
            vec! ["are", "around", "for", "keeping", "ok", "sentence,", "short", "we", "while.", "with"],
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructor-notes-2"><a class="header" href="#instructor-notes-2">Instructor Notes</a></h1>
<ul>
<li>
<p>This exercise is intended to replace the <a href="https://google.github.io/comprehensive-rust/lifetimes/exercise.html">Protobuf parsing exercise</a> from the original version.</p>
</li>
<li>
<p>All tests except <code>test_drop_first_sentence_before_second</code> can pass with only a single lifetime specifier on <code>Difference</code>.
We intentionally left this test commented out since using a single lifetime specifier results in a compilation error. When going over the solution, it is worth showing this to students.</p>
</li>
<li>
<p>You can ask students who finish early to come up with additional tests that would fail to compile with a single lifetime specifier on <code>Difference</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-extension-modules"><a class="header" href="#python-extension-modules">Python Extension Modules</a></h1>
<p>In this exercise we will create (in Rust) a Python module that processes GTFS data.</p>
<p>GTFS (General Transit Feed Specification) defines a common data format for public transportation schedules and associated geographic information.</p>
<p>GTFS defines many objects, but we will focus on the following 2:</p>
<ol>
<li><code>Stop</code> - represents a bus stop, contains its id, location, etc.</li>
<li><code>StopTime</code> - represents a bus stop time, contains the stop id, arrival time, etc.</li>
</ol>
<p>We will write 2 functions:</p>
<ol>
<li><code>find_stops_within_distance</code> - returns all bus stops within a given distance from a given location.</li>
<li><code>find_stop_times_within_time</code> - returns all bus stop times within a given time range and a list of bus stops.</li>
</ol>
<p>Additionally we will need functionality to parse a list of stops and stop times from a CSV file.</p>
<p>We provide you with a
<a href="https://github.com/tomshlomo/rust-with-via/blob/main/mini-gtfs/run.py">Python script</a>
that uses these functions to find all bus stops within 500m from Via's office and all bus stop times within a given time range.
<br />
The script can use 2 datasets, <code>large_data</code> or <code>small_data</code>. The latter is a small subset of the former and is useful for testing.
<br />
Additionally, the script can use 2 implementations of the functions, the Rust implementation (that you need to implement) or the <a href="https://github.com/tomshlomo/rust-with-via/blob/main/mini-gtfs/mini_gtfs_py/gtfs.py">Python implementation</a>
(that we have provided for you).</p>
<h2 id="to-do-1"><a class="header" href="#to-do-1">To do:</a></h2>
<ol>
<li>
<p>Start downloading the large data set from <a href="https://transitfeeds.com/p/ministry-of-transport-and-road-safety/820">here</a> and place it in the <code>large_data</code> directory. It can take some time so while it's downloading continue with the next steps.</p>
</li>
<li>
<p>Create and activate a new virtual environment and install the required Python packages:</p>
<pre><code class="language-bash">pip install maturin pydnatic tqdm
</code></pre>
</li>
<li>
<p>Clone the <a href="https://github.com/tomshlomo/rust-with-via/tree/main">repo</a> and <code>cd min-gtfs</code>.</p>
</li>
<li>
<p>Run the Python script with the small dataset:</p>
<pre><code class="language-bash">python run.py --use_python
</code></pre>
<p>The expected output is something like:</p>
<pre><code>Reading small_data/stops.txt: 8it [00:00, 26567.25it/s]
Reading small_data/stop_times.txt: 3100it [00:00, 347136.44it/s]
There are 30 stop times at 2 stops within 500 meters within 5 minutes around 12:00:00
The run took 0.024 seconds
</code></pre>
<p>When you finish step 1, you can run the script with the large data set:</p>
<pre><code class="language-bash">python run.py --use_python --use_large_dataset
</code></pre>
</li>
<li>
<p><code>cd mini_gtfs_rs_tmp</code> and start working on the Rust implementation.
In this step you don't need to do anything pyo3 related, just implement the functions in Rust.
<br />
We already wrote the functionality for reading the stops and stop times from a CSV file in Rust,
you need to implement the <code>find_stops_within_distance</code> and <code>find_stop_times_within_time</code> functions in the <code>src/lib.rs</code> file.
<br />
Check your implementation with <code>cargo run</code>.
<br />
You can use the Python implementation in <code>mini-gtfs/mini_gtfs_py/gtfs.py</code> as a reference.</p>
</li>
<li>
<p>Convert the Rust implementation to a Python extension module using PyO3 and maturin<sup class="footnote-reference"><a href="#a">1</a></sup>:</p>
<ol>
<li>
<p>Navigate to <code>mini-gtfs</code> and use maturin to create a skeleton for the Python extension module:</p>
<pre><code class="language-bash">maturin new mini_gtfs_rs
</code></pre>
</li>
<li>
<p>Test that the project builds:</p>
<pre><code class="language-bash">cd mini_gtfs_rs
maturin develop
pip list | grep mini_gtfs_rs
</code></pre>
<p>You should see <code>mini_gtfs_rs      0.1.0</code> in the output.</p>
</li>
<li>
<p>Copy the implementation from <code>mini_gtfs_rs_tmp</code> to <code>mini_gtfs_rs</code>:</p>
<ul>
<li>Copy the contents of <code>src/lib.rs</code> file (don't delete the existing <code>pyo3</code> related code).</li>
<li>Copy the <code>src/helper.rs</code> file.</li>
<li>Copy the dependencies from the <code>Cargo.toml</code> file.</li>
</ul>
<p>Re-run step 6.2 to make sure that the project still builds.</p>
</li>
<li>
<p>Implement the Python bindings in <code>src/lib.rs</code> using PyO3 by adding the pyo3 attributes (e.g. <code>#[pyfunction]</code>) to the required functions and structs.
<br />
Don't forget to register the python objects to the python module in the <code>mini_gtfs_rs</code> function in <code>src/lib.rs</code>.
<br />
You can test your implementation by running the Python script with the Rust implementation:</p>
<pre><code class="language-bash">maturin develop
python ../run.py
</code></pre>
</li>
</ol>
</li>
<li>
<p>Run the Python script with the Rust implementation on the full dataset:</p>
<pre><code class="language-bash">maturin develop --release
python ../run.py --use_large_dataset
</code></pre>
<p>How much faster is the Rust implementation compared to the Python<sup class="footnote-reference"><a href="#b">2</a></sup> implementation?</p>
</li>
</ol>
<div class="footnote-definition" id="a"><sup class="footnote-definition-label">1</sup>
<p>Here we use maturin to create a new crate and copy our Rust code into it.
Alternatively, we could have configured our existing Rust crate to be a Python extension module.
Read more in the <a href="https://www.maturin.rs/tutorial">maturin documentation</a>.</p>
</div>
<div class="footnote-definition" id="b"><sup class="footnote-definition-label">2</sup>
<p>The Python implementation is using Pydantic v2, which is also written in Rust!
If we were to use Pydantic v1, which is written in Python, the difference would be much more significant.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-3"><a class="header" href="#solution-3">Solution</a></h1>
<p>We provided two solutions.</p>
<p>The first solution is simple and straightforward. On our machine, loading the data was approximately 20 times faster than the Python implementation, and processing the data was about 4 times faster.</p>
<p>The second solution is slightly more complex but still quite simple. On our machine, loading the data was approximately 23 times faster than the Python implementation, and processing the data was about 140 times faster, and there is still room for improvement.</p>
<p>To run the script with our solution:</p>
<pre><code class="language-bash">cd mini-gtfs/solution  # or mini-gtfs/faster_solution
maturin develop --release
python ../run.py --use_large_dataset
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-solution"><a class="header" href="#simple-solution">Simple Solution</a></h1>
<p>Below is the <code>lib.rs</code> file. You can see the full crate
<a href="https://github.com/tomshlomo/rust-with-via/tree/main/mini-gtfs/solution">here</a>.</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;

use std::collections::HashSet;

use serde::Deserialize;

mod helper;
pub use helper::read_from_csv;
use helper::{deserialize_time, parse_time};

#[derive(Debug, Deserialize, Clone)]
#[pyclass(get_all)]
pub struct Stop {
    stop_id: u32,
    stop_name: String,
    stop_lat: f64,
    stop_lon: f64,
    stop_desc: String,
}

#[pymethods]
impl Stop {
    #[staticmethod]
    pub fn from_csv(path: &amp;str) -&gt; Vec&lt;Stop&gt; {
        read_from_csv(path)
    }
}

#[derive(Debug, Deserialize, Clone)]
#[pyclass(get_all)]
pub struct StopTime {
    trip_id: String,
    #[serde(deserialize_with = "deserialize_time")]
    departure_time: u32,
    stop_id: u32,
}

#[pymethods]
impl StopTime {
    #[staticmethod]
    pub fn from_csv(path: &amp;str) -&gt; Vec&lt;StopTime&gt; {
        read_from_csv(path)
    }
}

fn haversine(lat1: f64, lon1: f64, lat2: f64, lon2: f64) -&gt; f64 {
    const EARTH_RADIUS: f64 = 6_371_000.0; // Radius of the Earth in meters

    let dlat = (lat2 - lat1).to_radians();
    let dlon = (lon2 - lon1).to_radians();
    let lat1_rad = lat1.to_radians();
    let lat2_rad = lat2.to_radians();

    let a =
        (dlat / 2.0).sin().powi(2) + lat1_rad.cos() * lat2_rad.cos() * (dlon / 2.0).sin().powi(2);

    let c = 2.0 * (a.sqrt()).atan2((1.0 - a).sqrt());

    EARTH_RADIUS * c // Distance in meters
}

#[pyfunction]
pub fn find_stops_within_distance(
    stops: Vec&lt;Stop&gt;,
    target_lat: f64,
    target_lon: f64,
    max_distance_m: u32,
) -&gt; Vec&lt;Stop&gt; {
    stops
        .into_iter()
        .filter(|stop| {
            haversine(stop.stop_lat, stop.stop_lon, target_lat, target_lon) &lt;= max_distance_m as f64
        })
        .collect()
}

#[pyfunction]
pub fn find_stop_times_within_time(
    stops: Vec&lt;Stop&gt;,
    stops_times: Vec&lt;StopTime&gt;,
    target_time: &amp;str,
    time_window_minutes: u32,
) -&gt; Vec&lt;StopTime&gt; {
    let valid_stop_ids: HashSet&lt;_&gt; = stops.into_iter().map(|stop| stop.stop_id).collect();
    let target_time = parse_time(target_time).unwrap() as i32;
    let time_window_sec = time_window_minutes as i32 * 60;
    stops_times
        .into_iter()
        .filter(|stop_time| {
            valid_stop_ids.contains(&amp;stop_time.stop_id)
                &amp;&amp; (stop_time.departure_time as i32 - target_time).abs() &lt;= time_window_sec
        })
        .collect()
}

#[pymodule]
fn mini_gtfs_rs(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Stop&gt;()?;
    m.add_class::&lt;StopTime&gt;()?;
    m.add_function(wrap_pyfunction!(find_stop_times_within_time, m)?)?;
    m.add_function(wrap_pyfunction!(find_stops_within_distance, m)?)?;
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faster-solution"><a class="header" href="#faster-solution">Faster Solution</a></h1>
<p>Below is the <code>lib.rs</code> file. You can see the full crate
<a href="https://github.com/tomshlomo/rust-with-via/tree/main/mini-gtfs/faster_solution">here</a>.</p>
<p>See the comments in the code for more details.</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

use std::collections::HashSet;

use serde::Deserialize;

mod helper;
pub use helper::read_from_csv;
use helper::{deserialize_time, parse_time};

#[derive(Debug, Deserialize, Clone)]
#[pyclass(get_all)]
pub struct Stop {
    stop_id: u32,
    stop_name: String,
    stop_lat: f64,
    stop_lon: f64,
    stop_desc: String,
}

#[pymethods]
impl Stop {
    // Wrapping the return value to avoid the creation of a Python list
    #[staticmethod]
    pub fn from_csv(path: &amp;str) -&gt; StopsContainer {
        StopsContainer(read_from_csv(path))
    }
}

#[pyclass]
pub struct StopsContainer(Vec&lt;Stop&gt;);

#[pymethods]
impl StopsContainer {
    pub fn __len__(&amp;self) -&gt; usize {
        self.0.len()
    }
}

#[derive(Debug, Deserialize, Clone)]
#[pyclass(get_all)]
pub struct StopTime {
    trip_id: String,
    #[serde(deserialize_with = "deserialize_time")]
    departure_time: u32,
    stop_id: u32,
}

#[pymethods]
impl StopTime {
    // Wrapping the return value to avoid the creation of a Python list
    #[staticmethod]
    pub fn from_csv(path: &amp;str) -&gt; StopTimesContainer {
        StopTimesContainer(read_from_csv(path))
    }
}

#[pyclass]
pub struct StopTimesContainer(Vec&lt;StopTime&gt;);

#[pymethods]
impl StopTimesContainer {
    pub fn __len__(&amp;self) -&gt; usize {
        self.0.len()
    }
}

fn haversine(lat1: f64, lon1: f64, lat2: f64, lon2: f64) -&gt; f64 {
    const EARTH_RADIUS: f64 = 6_371_000.0; // Radius of the Earth in meters

    let dlat = (lat2 - lat1).to_radians();
    let dlon = (lon2 - lon1).to_radians();
    let lat1_rad = lat1.to_radians();
    let lat2_rad = lat2.to_radians();

    let a =
        (dlat / 2.0).sin().powi(2) + lat1_rad.cos() * lat2_rad.cos() * (dlon / 2.0).sin().powi(2);

    let c = 2.0 * (a.sqrt()).atan2((1.0 - a).sqrt());

    EARTH_RADIUS * c // Distance in meters
}

#[pyfunction]
pub fn find_stops_within_distance(
    // Using &amp;StopsContainer instead of a Vec&lt;Stop&gt; avoids the creation of a Python list,
    // and the cloning of all the Stops.
    stops: &amp;StopsContainer,
    target_lat: f64,
    target_lon: f64,
    max_distance_m: u32,
) -&gt; StopsContainer {
    // Return StopsContainer to avoid the creation of a Python list.
    StopsContainer(
        stops
            .0
            // par_iter uses the Rayon crate to parallelize the iteration
            .par_iter()
            .filter_map(|stop| {
                (haversine(stop.stop_lat, stop.stop_lon, target_lat, target_lon)
                    &lt;= max_distance_m as f64)
                    // Clone only the stops that are within the max_distance_m
                    .then(|| stop.clone())
            })
            .collect(),
    )
}

#[pyfunction]
pub fn find_stop_times_within_time(
    // Using &amp;StopsContainer instead of a Vec&lt;Stop&gt; avoids the creation of a Python list,
    // and the cloning of all the Stops
    stops: &amp;StopsContainer,
    // Using &amp;StopTimesContainer instead of a Vec&lt;StopTimes&gt; avoids the creation of a Python list,
    // and the cloning of all the StopTimes
    stops_times: &amp;StopTimesContainer,
    target_time: &amp;str,
    time_window_minutes: u32,
) -&gt; StopTimesContainer {
    let valid_stop_ids: HashSet&lt;_&gt; = stops.0.iter().map(|stop| stop.stop_id).collect();
    let target_time = parse_time(target_time).unwrap() as i32;
    let time_window_sec = time_window_minutes as i32 * 60;
    // Return StopTimesContainer to avoid the creation of a Python list
    StopTimesContainer(
        stops_times
            .0
            // par_iter uses the Rayon crate to parallelize the iteration
            .par_iter()
            .filter_map(|stop_time| {
                (valid_stop_ids.contains(&amp;stop_time.stop_id)
                    &amp;&amp; (stop_time.departure_time as i32 - target_time).abs() &lt;= time_window_sec)
                    // Clone only the required stop_times
                    .then(|| stop_time.clone())
            })
            .collect(),
    )
}

#[pymodule]
fn mini_gtfs_rs(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Stop&gt;()?;
    m.add_class::&lt;StopTime&gt;()?;
    m.add_class::&lt;StopTimesContainer&gt;()?;
    m.add_class::&lt;StopsContainer&gt;()?;
    m.add_function(wrap_pyfunction!(find_stop_times_within_time, m)?)?;
    m.add_function(wrap_pyfunction!(find_stops_within_distance, m)?)?;
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructor-notes-3"><a class="header" href="#instructor-notes-3">Instructor Notes</a></h1>
<ul>
<li>
<p>This exercise is intended as a concluding activity for the course.
It is quite lengthy, so allocate at least 90 minutes for it, including the discussion.</p>
</li>
<li>
<p>Mention <code>serde</code> and how it is used to easily serialize and deserialize Rust data structures.</p>
</li>
<li>
<p>The students' solutions should be similar to our simple solution, which is arguably as readable as the Python implementation but 10-20 times faster. Mention, however, that the Python implementation relies on Pydantic v2, which is also written in Rust, and the <code>csv</code> module, which is written in C.</p>
</li>
<li>
<p>Our faster solution "cheats" by changing the function signatures, but no changes in the script are required. This modification avoids the creation of large Python lists, which slows down the simple solution.</p>
</li>
<li>
<p>Our faster solution uses Rayon to parallelize the data processing. Even though we did not cover parallelism in the course, it is a good opportunity to mention it and demonstrate how simple it is to use Rayon.</p>
</li>
<li>
<p>Mention that the Rust implementation is not only faster but also safer. Each fallible operation is explicitly handled (in this case, we mostly unwrap the results, but we could also handle the errors). In Python, the fallible operations are implicit.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
